// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: cloud-openshift-operator
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2020-07-11
:page-description: Explore how to deploy an application to Red Hat OpenShift using Kubernetes Operators.
:page-tags: ['Kubernetes', 'Docker', 'Cloud'] 
:page-permalink: /guides/{projectid}
:page-related-guides: ['cloud-openshift', 'okd']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Deploying an application to Red Hat OpenShift using Kubernetes Operators
:page-seo-description: A getting started guide with examples on how to deploy an application on a Red Hat OpenShift cluster using Kubernetes Operators.
:guide-author: Open Liberty
= Deploying an application to OpenShift using Kubernetes Operators

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website^].

Explore how to deploy an application to Red Hat OpenShift using Kubernetes Operators.

== What you'll learn 

You will learn how to deploy an application to Red Hat OpenShift using Kubernetes Operators.

https://www.openshift.com/[OpenShift^] is a Kubernetes-based platform with added functions. It streamlines the DevOps
process by providing an intuitive development pipeline. It also provides integration with multiple tools to make the
deployment and management of cloud applications easier.

The application in this guide consists of two microservices, `system` and `inventory`. Every 15 seconds, the `system`
microservice calculates and publishes events that contain its current average system load. The `inventory` microservice
subscribes to that information so that it can keep an updated list of all the systems and their current system loads.
The current inventory of systems can be accessed via the `/systems` REST endpoint. You will deploy the two Open Liberty
microservices using the Open Liberty Operator, and deploy Kafka using the Strimzi Operator.
You can learn more about how the reactive Java services used in this guide work by checking out the
https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating reactive Java microservices^] guide.
Please refer to the figure below for a diagram of the application used in this guide.

image::reactive-messaging-system-inventory-rest.png[Reactive system inventory,align="center"]

The https://github.com/OpenLiberty/open-liberty-operator[Open Liberty Operator^] provides a method of packaging,
deploying, and managing Open Liberty applications on Kubernetes-based clusters. The Open Liberty Operator watches Open
Liberty resources and creates various Kubernetes resources, including `Deployments`, `Services`, and `Routes`, depending
on the configurations. The Operator then continuously compares the current state of the resources and the desired state
of application deployment and reconciles them when necessary. Operators provide an easy way to automate the management
and robust updating of applications, abstracting some of the details around cloud application management.
To learn more about OpenShift Operators, check out this https://www.openshift.com/learn/topics/operators[Operators tech topic article^].

== Additional prerequisites

Before you begin, you need the following tools:

- *OpenShift cluster*: You need admin access and control over the OpenShift cluster that you deploy your application to.
Check the next section `Accessing an OpenShift cluster` for recommendations and details.

- *Docker*: You need a containerization software for building containers. You will use Docker in this guide. For
installation instructions, refer to the official https://docs.docker.com/install/[Docker documentation^].

// Getting Started block

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

== Accessing an OpenShift cluster

Before you can deploy your microservices, you must gain access to a cluster on OpenShift.

There are various OpenShift offerings. You can use their https://www.openshift.com/try[online sandbox^], which provides
free access to an OpenShift cluster for 60 minutes, gain access to an OpenShift cluster hosted on
https://www.openshift.com/products/openshift-ibm-cloud[IBM cloud^], or check out their other offerings
https://www.openshift.com/products[here^]. Once you have access to a cluster, make sure you are logged in to the cluster
as a cluster administrator before proceeding with the guide.

Before you install any resources, you need a project on your OpenShift cluster. Create a project named `guide` by
running the following command:

[role='command']
```
oc new-project guide
```

== Installing the Operators

To install the two Operators, navigate to the web console, then to *Operators > OperatorHub* on the sidebar.
Search for and install the *Open Liberty Operator* and the *Strimzi Operator*.

Run the following command to view all the supported API resources available through the Open Liberty Operator:

[role='command']
```
oc api-resources --api-group=openliberty.io
```

You see the following output, which shows the custom resource definitions (CRDs) that are installed by the Operator for use:

[role='no_copy']
```
NAME                      SHORTNAMES         APIGROUP         NAMESPACED   KIND
openlibertyapplications   olapp,olapps       openliberty.io   true         OpenLibertyApplication
openlibertydumps          oldump,oldumps     openliberty.io   true         OpenLibertyDump
openlibertytraces         oltrace,oltraces   openliberty.io   true         OpenLibertyTrace
```

The Open Liberty Operator introduces new
https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[CRDs^],
including the `OpenLibertyApplication`. The `OpenLibertyApplication` CRD defines a set of configurations for
deploying an Open Liberty-based application, including the application image, number of instances, and storage settings.

You will be using the `OpenLibertyApplication` resource in the upcoming sections.

== Deploying the Kafka service to OpenShift

//File 0
kafka.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/kafka.yaml[]
----

Apache Kafka is the messaging broker that's used in this application. The Strimzi Operator simplifies the deployment
and management of Kafka clusters. To learn more about Strimzi, visit their https://strimzi.io/[official website^].

You can configure the specifics of the Strimzi Operator-controlled Kafka deployment with a YAML configuration file.

Ensure that you are in the `start` directory.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `kafka.yaml` configuration file.#
`kafka.yaml`
----

The Kafka cluster configuration is based on the
https://github.com/strimzi/strimzi-kafka-operator/blob/master/examples/kafka/kafka-ephemeral-single.yaml[Strimzi Kafka ephemeral single example^].
For more information about the Kafka configuration file, check out the
https://strimzi.io/docs/operators/master/using.html#assembly-deployment-configuration-kafka-str[official Strimzi documentation^]

Run the following command to deploy Kafka using the newly created configuration file:

[role='command']
```
oc apply -f kafka.yaml
```

Run the following command to view the details of the deployment:

[role='command']
```
oc get kafka/kafka-cluster
```

== Deploying the system and inventory applications to OpenShift

//File 0
build.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/build.yaml[]
----

//File 1
deploy.yaml
[source, yaml, linenums, role='code_column hide_tags=replicas']
----
include::finish/deploy.yaml[]
----

To deploy the Open Liberty `system` and `inventory` applications, you must first package the applications and build the Docker
images. Then, you need to push the images to the internal OpenShift registry and deploy the images by using the Open Liberty Operator.

=== Packaging the applications

Ensure that you are in the `start` directory and run the following commands to package the `system` and `inventory`
applications:

[role='command']
```
mvn -pl models clean install
mvn clean package
```

=== Building and pushing the images

Create a build template to configure how to build your images.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `build.yaml` template file.#
`build.yaml`
----

The [hotspot file=0]`build.yaml` template includes two objects. The [hotspot=imageStream file=0]`image stream` object provides an abstraction
from the image in the image registry, allowing you to reference and tag the image. The image registry that is used is
the integrated internal OpenShift Container Registry.

The [hotspot=buildConfig file=0]`build configuration` object defines a single
build definition and any triggers that kickstart the build. The [hotspot=source file=0]`source` spec defines the build input. In this case,
the build inputs are your [hotspot=binary file=0]`binary` (local) files, which are streamed to OpenShift for the build. The template specifies
a [hotspot=docker file=0]`Docker` strategy build, which invokes the `docker build` command, and creates a runnable application image
from the build input. The template is parameterized with the [hotspot=appname file=0]`APP_NAME` parameter so that the same
template can be used to create the objects for the `system` and `inventory` applications separately.

include::{common-includes}/ol-kernel-docker-pull.adoc[]

Run the following commands to create the objects for the `system` and `inventory` applications:

[role='command']
```
oc process -f build.yaml -p APP_NAME=system | oc create -f -
oc process -f build.yaml -p APP_NAME=inventory | oc create -f -
```

Next, run the following commands to view the newly created image streams and build configurations for each application:

[role='command']
```
oc get all -l name=system
oc get all -l name=inventory
```

You see the following resources:

[role='no_copy']
```
NAME                                                TYPE     FROM     LATEST
buildconfig.build.openshift.io/system-buildconfig   Docker   Binary   0

NAME                                                IMAGE REPOSITORY                                                            TAGS           UPDATED
imagestream.image.openshift.io/system-imagestream   image-registry.openshift-image-registry.svc:5000/guide/system-imagestream   1.0-SNAPSHOT   2 days ago

...

NAME                                                   TYPE     FROM     LATEST
buildconfig.build.openshift.io/inventory-buildconfig   Docker   Binary   2

NAME                                                   IMAGE REPOSITORY                                                               TAGS           UPDATED
imagestream.image.openshift.io/inventory-imagestream   image-registry.openshift-image-registry.svc:5000/guide/inventory-imagestream   1.0-SNAPSHOT   2 days ago
```

Ensure that you are in the `start` directory and trigger the builds by running the following commands:

[role='command']
```
oc start-build system-buildconfig --from-dir=system/.
oc start-build inventory-buildconfig --from-dir=inventory/.
```

The local `system` and `inventory` directories are uploaded to OpenShift to be built into the Docker images. Run the
following command to list the builds and track their status:

[role='command']
```
oc get builds
```

You see the following output:

[role='no_copy']
```
NAME                      TYPE     FROM             STATUS     STARTED
system-buildconfig-1      Docker   Binary@f24cb58   Running    45 seconds ago
inventory-buildconfig-1   Docker   Binary@f24cb58   Running    13 seconds ago
```

You may need to wait some time until the build is complete. To check whether the build is complete, run the following
commands to view the build logs until the `Push successful` message appears:

[role='command']
```
oc logs build/system-buildconfig-1
oc logs build/inventory-buildconfig-1
```

Run the following command to view the image streams:

[role='command']
```
oc get imagestreams
```

Run the following commands to get more details on the newly pushed images within the streams:

[role='command']
```
oc describe imagestream/system-imagestream
oc describe imagestream/inventory-imagestream
```

This example partially shows the `system-imagestream` output:

[role='no_copy']
```
Name:                     system-imagestream
Namespace:                guide
Created:                  2 minutes ago
Labels:                   name=system
Annotations:              <none>
Image Repository:         image-registry.openshift-image-registry.svc:5000/guide/system-imagestream
Image Lookup:             local=false
Unique Images:            1
Tags:                     1

...
```

You'll get a similar output for the `inventory-imagestream`.

Now you're ready to deploy the images.

=== Deploying the images

You can configure the specifics of the Open Liberty Operator-controlled deployment with a YAML configuration file.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `deploy.yaml` configuration file.#
`deploy.yaml`
----

The [hotspot file=1]`deploy.yaml` file is configured to deploy two [hotspot=olapp1 hotspot=olapp2 file=1]`OpenLibertyApplication`
resources, [hotspot=system file=1]`system` and [hotspot=inventory file=1]`inventory`, which will be controlled by
the Open Liberty Operator.

The [hotspot=sysImage file=1]`applicationImage` parameter value is the only necessary parameter, and can be set by using the
`<project-name>/<image-stream-name>[:tag]` format. The parameter can also point to an image hosted on an external registry, such as
Docker Hub. The [hotspot=system file=1]`system` application is configured to use the
[hotspot=sysImage file=1]`image` created from the earlier build. By default, the operator automatically redeploys
applications when it detects a new image was pushed into the `ImageStream`. If you are using an external image, you can define
the pull policy by using a `pullPolicy` configuration parameter. The
[hotspot=systemEnv file=1]`env` parameter is used to specify environment variables that are passed to the container at runtime.
You need to specify the bootstrap address required to communicate with the deployed Kafka cluster as an environment variable.
Update the [hotspot=bootstrap hotspot=bootstrapInv file=1]`value` of the bootstrap address variable to the required values. You can find the
bootstrap address by running the following command:

[role='command']
```
oc get kafka kafka-cluster -o=jsonpath='{.status.listeners[?(@.type=="plain")].bootstrapServers}{"\n"}'
```

The [hotspot=inventory file=1]`inventory` application is configured similarly to the [hotspot=system file=1]`system`
application. Additionally, the `inventory` application includes the [hotspot=service file=1]`service` and
[hotspot=expose file=1]`expose` parameters. The [hotspot=servicePort file=1]`service.port` parameter specifies which port
is exposed by the container, allowing the application to be accessed from outside the container. To access the application
from outside of the cluster, it must be exposed, by setting the [hotspot=expose file=1]`expose` parameter to `true`.
Exposing the application lets the Operator automatically create and configure routes for external access to your application.

Run the following command to deploy the `system` and `inventory` applications with the previously explained configurations:

[role='command']
```
oc apply -f deploy.yaml
```

Next, run the following command to view your newly created `OpenLibertyApplication` resources:

[role='command']
```
oc get OpenLibertyApplications
```

You can also substitute `OpenLibertyApplications` with the short form `olapps`.

Run the following commands to view details of your applications:

[role='command']
```
oc describe olapps/system
oc describe olapps/inventory
```

This example partially shows the `olapps/system` output:

[role='no_copy']
```
Name:         system
Namespace:    guide
Labels:       app.kubernetes.io/part-of=system
              name=system
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"openliberty.io/v1beta1","kind":"OpenLibertyApplication","metadata":{"annotations":{},"labels":{"name":"system"},"name":"sys...
API Version:  openliberty.io/v1beta1
Kind:         OpenLibertyApplication

...
```

You'll get a similar output for `olapps/inventory`.

== Accessing the inventory application

To access the exposed `inventory` application, run the following command and make note of the `HOST`:

[role='command']
```
oc get routes
```

You see an output similar to:

[role='no_copy']
```
NAME        HOST/PORT                                    PATH   SERVICES    PORT       TERMINATION   WILDCARD
inventory   inventory-guide.apps.lights.os.fyre.ibm.com         inventory   9085-tcp                 None
```


Visit the `inventory` application by going to the following URL. Make sure to substitute the appropriate `HOST`:
`http://[HOST]/inventory/systems`

For example, `inventory-guide.apps.lights.os.fyre.ibm.com` is the `HOST` in the
`\http://inventory-guide.apps.lights.os.fyre.ibm.com/inventory/systems` URL.

You see a JSON response similar to the following example, but your JSON response might not be formatted. The sample output
was formatted for readability:

[role='no_copy']
```
[
    {
        "hostname": "system-7cbc47455c-664wh",
        "systemLoad": 1.15
    }
]
```

== Scaling up the system application

//File 0
deploy.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/deploy.yaml[]
----

The `inventory` application displays the `hostname` and `systemLoad` of all `system` applications that are publishing
messages to the Kafka broker. Since only one `system` pod is running, there is only one element in the `inventory`.
Scaling applications up is easy with Operators. Simply update the `deploy.yaml` file with the `replica: n` parameter,
where `n` is the number of instances that you want.

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `deploy.yaml` configuration file.#
`deploy.yaml`
----
[role="edit_command_text"]
Add the [hotspot=replicas file=0]`replicas` parameter to the `system` configuration.

Run the following command to update the `system` resource:

[role='command']
```
oc apply -f deploy.yaml
```

You see the following output:

[role='no_copy']
```
openlibertyapplication.openliberty.io/system configured
openlibertyapplication.openliberty.io/inventory unchanged
```

Notice that only the `system` resource was updated because there was a change in its specification. The `inventory`
resource was left unchanged.

Wait a few minutes, then run the following command to see the newly scaled up `system` pods:

[role='command']
```
oc get pods
```

Revisit the `inventory` application and you now see three elements:

[role='no_copy']
```
[
    {
        "hostname": "system-5bb7b86fd5-b5plz",
        "systemLoad": 2.73
    },
    {
        "hostname": "system-5bb7b86fd5-fkd5j",
        "systemLoad": 2.95
    },
    {
        "hostname": "system-5bb7b86fd5-pgcbf",
        "systemLoad": 2.73
    }
]
```

== Tearing down the environment

When you no longer need your project, switch to another project and delete the project `guide` by running the following command:

[role='command']
```
oc delete project guide
```

This command deletes all the applications and resources.

== Great work! You're done!

You just deployed two microservices running in Open Liberty to OpenShift using the Open Liberty Operator.

== Related Links

// Multipane
include::{common-includes}/attribution.adoc[subs="attributes"]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
